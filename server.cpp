#include <iostream>
#include <cstring> // для работы с функциями C, такими как memset.
#include <unistd.h> // для системных вызовов, таких как close и usleep.
#include <sys/socket.h> //  для работы с сокетами.
#include <netinet/in.h> // для структуры sockaddr_in и других сетевых функций.
#include <thread> // для работы с потоками
#include <mutex> // для синхронизации потоков.
#include <vector>
#include <algorithm>
#include <fstream>  // Для работы с файлами




using namespace std;
vector<int> users;  // Вектор для хранения сокетов подключённых клиентов
// mutex (мьютекс) нужен для синхронизации доступа к общим ресурсам между потоками. 
// Он предотвращает одновременное изменение общих данных несколькими потоками, что может привести к некорректным результатам или даже к сбоям программы.
mutex client_sockets_mutex;  // Мьютекс для защиты доступа к списку клиентов (Мьютекс для синхронизации доступа к списку клиентов.)
mutex file_mutex; // Мьютекс для синхронизации доступа к файлу истории.
const string history_filename = "chat_history.txt";  // файл для хранения истории




// Функция для записи сообщения в файл
void save_message_to_file(const string& message) 
{
    lock_guard<mutex> lock(file_mutex);
    // Использует lock_guard для автоматической блокировки/разблокировки мьютекса file_mutex.
    ofstream history_file(history_filename, ios::app);  // открываем файл в ржиме добавления
    // создаёт объект ofstream (поток записи в файл), связанный с файлом chat_history.txt, и открывает его в режиме добавления (ios::app). 

    // Разбор строки:
    // 1) ofstream:
    // Это класс из стандартной библиотеки C++, предназначенный для записи данных в файл.
    // Объект history_file создаёт поток для записи.
    // 2) history_filename:
    // Переменная типа string, содержащая имя файла ("chat_history.txt").
    // Файл с этим именем будет открыт.
    // 3) ios::app:
    // Режим открытия файла, который указывает, что данные должны добавляться в конец файла.
    // 4) Особенности режима ios::app:
    // Если файл существует, новые данные будут добавлены в конец, без перезаписи старых.
    // Если файл не существует, он будет создан.
    if (history_file.is_open()) {
        history_file << message << endl;  // записываем в файл
        history_file.close();  // закрываем файл
    }
}




// функция для отправки истории клиенту
void send_chat_history(int client_socket) 
{
    lock_guard<mutex> lock(file_mutex);
    // Используется lock_guard для автоматической блокировки и разблокировки мьютекса file_mutex.
    // Зачем нужен мьютекс?
    // Файл chat_history.txt может одновременно читаться или записываться разными потоками (например, когда другой клиент отправляет новое сообщение).
    // Мьютекс предотвращает одновременный доступ к файлу, обеспечивая консистентность данных.
    ifstream history_file(history_filename);  // открыть файл для чтения
    // ifstream в C++ — это поток для работы с файлами в режиме чтения.
    // Создаётся объект ifstream для чтения содержимого файла chat_history.txt.
    // Если файл не существует или не может быть открыт, history_file не будет в состоянии open, и последующий код проигнорирует пустой поток.
    string line;
    while (getline(history_file, line)) {  // читаем построчно (Читает одну строку из файла и сохраняет её в переменную line.)
        send(client_socket, line.c_str(), line.length(), 0);  // отправляем каждую строчку клиенту
        // Отправляет строку клиенту через сокет:
        // client_socket — сокет клиента.
        // line.c_str() — указатель на данные строки в стиле C.
        // line.length() — длина строки (в байтах), которая отправляется.
        // 0 — стандартный флаг для send.
        usleep(1000);  // задержка чтобы буфер не переполнялся
        // Задержка в 1000 микросекунд (1 миллисекунда).
        // Зачем?
        // Чтобы избежать переполнения буфера клиента.
        // Если клиент обрабатывает данные медленно, задержка предотвращает сбой соединения.
    }
    history_file.close();  // закрываем файл
}





// Функция для обработки подключенного клиента
void handle_client(int client_socket) {
    {
        lock_guard<mutex> lock(client_sockets_mutex);
        // Используется для защиты доступа к списку users с помощью мьютекса client_sockets_mutex.
        // Гарантирует, что доступ к общему ресурсу безопасен, даже если несколько потоков одновременно пытаются изменить список.
        users.push_back(client_socket); // Добавляет сокет клиента в список всех подключённых клиентов (users).
    }

    char buffer[1024];
    // Буфер для хранения данных, получаемых от клиента.
    // Размер 1024 байта позволяет обрабатывать сообщения средней длины.
    string name;

    // Чтение имени пользователя
    int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
    // Получает данные от клиента через сокет.
    // Возвращает количество байт, которые были получены.
    // Если результат больше 0, значит, данные успешно получены.
    if (bytes_received > 0) {
        name = string(buffer, bytes_received); // Преобразует данные из буфера в строку, чтобы сохранить имя клиента.
    }

    // отправляем историю новому клиенту
    send_chat_history(client_socket);

    while (true) {
        memset(buffer, 0, sizeof(buffer));  // Очищаем буфер (Обнуляет буфер перед использованием, чтобы удалить старые данные.)
        bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        // Получает сообщение от клиента.
        // Если bytes_received <= 0, это означает, что клиент отключился или произошла ошибка.

        

        // Проверка на завершение соединения
        if (bytes_received <= 0) {
            cout << "Client disconnected." << endl;
            close(client_socket);
            lock_guard<mutex> lock(client_sockets_mutex);
            // обеспечивают безопасное удаление сокета клиента (client_socket) из списка подключённых клиентов (users) после его отключения.
            users.erase(remove(users.begin(), users.end(), client_socket), users.end());
            // Как это работает:

            // 1) remove(users.begin(), users.end(), client_socket):
            // Алгоритм remove из STL ищет все элементы в диапазоне [users.begin(), users.end()), равные client_socket, и "перемещает" их в конец вектора.
            // Возвращает итератор на новый конец "актуальных" данных.
            // Однако remove не изменяет размер вектора, а только переставляет элементы.
            // 2) users.erase(..., users.end()):
            // Удаляет все элементы, начиная с итератора, который вернул remove, до конца вектора (users.end()).
            // Это окончательно удаляет client_socket из списка users.
            // 3) Почему используется remove вместе с erase?
            // Это идиоматический подход в C++ для удаления элементов из контейнеров, таких как std::vector, без изменения порядка оставшихся элементов.
            
            break;
        }
        // Закрывает сокет клиента.
        // Удаляет сокет из списка users с защитой мьютексом.
        // Прерывает цикл.



        
        // Преобразует полученные данные в строку с завершающим символом \0.
        buffer[bytes_received] = '\0';  // Завершаем строку символом '\0'
        string note = "[" + name + "] " + buffer;
        cout << note << endl;

        save_message_to_file(note);  // сохраняем сообщение в файл


        // отвечают за отправку нового сообщения от клиента всем остальным клиентам, подключённым к серверу, за исключением самого отправителя. 
        // Давайте разберём каждую часть подробнее.
        lock_guard<mutex> lock(client_sockets_mutex);
        for (int user_socket : users) { // Перебирает все сокеты, хранящиеся в списке users.
                                        // user_socket — текущий сокет, с которым идёт итерация.
            if (user_socket != client_socket)
                // Зачем эта проверка?
                // Сообщение должно отправляться только другим клиентам.
                // Если отправить сообщение самому себе, клиент получит дубликат, что неправильно в контексте чата.
                // client_socket — сокет отправителя текущего сообщения.
                send(user_socket, note.c_str(), note.length(), 0);
                // Функция для отправки данных через сокет.
                // Аргументы:
                // 1) user_socket:
                // Сокет клиента, которому отправляется сообщение.
                // 2) note.c_str():
                // Указатель на данные строки в стиле C.
                // Сообщение, которое нужно отправить.
                // 3) note.length():
                // Длина строки note (в байтах).
                // 4) 0:
                // Флаг. Значение 0 указывает на стандартное поведение отправки.
        }
    }
}





int main() {
    // Создание сокета
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    // Для создания сокета на C++ используется функция socket(). 23 Она привязывает созданный сокет к заданной параметрами транспортной инфраструктуре сети. 
    // Прототип функции: SOCKET socket(int <семейство используемых адресов>, int <тип сокета>, int <тип протокола>). 
    // Параметры:
    // Семейство адресов. Сокеты могут работать с большим семейством адресов, наиболее частое — IPv4 (указывается как AF_INET). 
    // Тип сокета. Обычно задаётся тип транспортного протокола TCP (SOCK_STREAM) или UDP (SOCK_DGRAM).  
    // Тип протокола. Необязательный параметр, если тип сокета указан как TCP или UDP — можно передать значение 0. 

    if (server_socket == -1) {
        cerr << "ERROR: cannot create socket" << endl;
        return 1;
    }




    
    // Установка опции SO_REUSEADDR
    //     Зачем нужен?
    
    // Когда сервер завершает работу, его сокет переходит в состояние TIME_WAIT для завершения всех соединений.
    // В это время адрес и порт остаются заблокированными, и сервер не сможет перезапуститься с теми же параметрами.
    // Установка SO_REUSEADDR позволяет использовать адрес и порт сразу после закрытия сокета.
    // Как это работает?
    
    // Если SO_REUSEADDR установлен, система позволяет привязать новый сокет к тому же адресу и порту, даже если старый сокет ещё в состоянии TIME_WAIT.

    
    // устанавливают параметр сокета SO_REUSEADDR, который позволяет повторно использовать адрес и порт, если сервер перезапускается.
    int opt = 1; // Задаёт значение 1 для включения опции SO_REUSEADDR.
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) 
    // &opt и sizeof(opt):
    // Указывают, что параметр SO_REUSEADDR должен быть включён (значение 1).
    { 
        // setsockopt (set socket options) — это функция для настройки параметров сокета. Она позволяет изменить поведение сокета или системы, связанной с ним.
        // 1) sockfd:
        // Файловый дескриптор сокета, для которого устанавливаются параметры.
        // Здесь это server_socket.
        // 2) level:
        // Уровень, на котором задаётся параметр.
        // SOL_SOCKET — настройки уровня сокета (общие параметры для сокетов).
        // 3) optname:
        // Имя параметра, который нужно установить.
        // SO_REUSEADDR:
        // Позволяет сокету повторно использовать адрес, даже если он недавно был закрыт.
        // 4) optval:
        // Указатель на значение параметра.
        // Здесь это &opt (адрес переменной opt), где opt = 1.
        // 4) optlen:
        // Размер значения параметра в байтах.
        // Здесь это sizeof(opt).
        // 6) Возвращаемое значение:
        // 0 — успех.
        // -1 — ошибка (например, если сокет недоступен или параметр недопустим).
        cerr << "ERROR: setsockopt failed" << endl;
        close(server_socket);
        return 1;
    }

    // Настройка адреса и порта сервера
    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(12345);  // Порт 12345
    // struct sockaddr_in serverAddr — это структура, которая содержит адрес сервера и номер порта, на который нужно установить связь. 
    // Некоторые поля структуры:
    // serverAddr.sin_addr.s_addr — адрес сервера (по умолчанию INADDR_ANY); 12
    // serverAddr.sin_family — семейство адреса (AF_INET); 13
    // serverAddr.sin_port — номер порта (например, 8989). 
    // Например, для установки IP-адреса localhost можно использовать следующее назначение полей: serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1"). 
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    // INADDR_ANY:
    // Специальное значение, которое указывает, что сервер должен принимать соединения на всех сетевых интерфейсах 
        // (например, локальный адрес 127.0.0.1 и внешний IP).
    // Это удобно, если у сервера несколько сетевых интерфейсов.




    
    // Привязка сокета к адресу и порту
    if (bind(server_socket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {
        // проверяют успешность вызова функции bind, которая привязывает серверный сокет к указанному адресу (serverAddr) и порту. 
        // Если привязка не удалась, выводится сообщение об ошибке, сокет закрывается, и программа завершается.
        //         Зачем нужна привязка?
        // Привязка сокета с помощью bind позволяет серверу:
        
        // Слушать соединения на указанном адресе и порту.
        // Сообщить системе, где ожидать входящие подключения.
        // Без вызова bind сокет не будет ассоциирован с конкретным адресом и портом, и сервер не сможет принимать входящие соединения.
        cerr << "ERROR: cannot bind socket to address" << endl;
        close(server_socket);
        return 1;
    }




    
    // Ожидание входящих соединений.
    // переводят серверный сокет в режим прослушивания входящих соединений. Если это действие завершается с ошибкой, выводится сообщение,
    // сокет закрывается, и программа завершается.
    if (listen(server_socket, 5) == -1) {
        // 1) sockfd:
        // Файловый дескриптор сокета, который был успешно создан и привязан к адресу и порту (с помощью bind).
        // Здесь это server_socket.
        // 2) backlog:
        // Максимальное количество подключений, которые могут находиться в очереди ожидания.
        // Если все доступные соединения уже обработаны, новые соединения будут отклонены, пока в очереди нет места.
        // Здесь значение 5 задаёт максимальный размер очереди.
        cerr << "ERROR: cannot listen on socket" << endl;
        close(server_socket);
        return 1;
    }

    cout << "Server is listening on port 12345..." << endl;



    
    // Основной цикл сервера
    //     Сервер работает в бесконечном цикле, постоянно ожидая входящих соединений.
    // Завершение сервера в таком цикле обычно происходит по внешнему сигналу (например, через прерывание).
    while (true) {
        // Принятие нового соединения от клиента
        int client_socket = accept(server_socket, NULL, NULL);
        //         Функция accept:
        // Принимает новое входящее соединение от клиента.
        // Возвращает файловый дескриптор (client_socket), связанный с этим соединением.
        // Сервер может использовать этот дескриптор для общения с клиентом.
        // СИНТАКСИС:
        // 1) sockfd:
        // Файловый дескриптор сокета, который находится в режиме прослушивания.
        // Здесь это server_socket.
        // 2) addr:
        // Указатель на структуру sockaddr, куда записывается информация о подключённом клиенте (например, его IP-адрес и порт).
        // В данном случае передаётся NULL, так как сервер не использует эту информацию.
        // 3) addrlen:
        // Указатель на размер структуры addr.
        // Также передаётся NULL, так как адрес клиента не требуется.
        
        // Возвращаемое значение:
        // Если соединение успешно принято, возвращается файловый дескриптор нового сокета (client_socket).
        // Если произошла ошибка, возвращается -1.
        if (client_socket == -1) {
            cerr << "ERROR: cannot accept incoming connection" << endl;
            continue;  // Пропустить ошибку и продолжить слушать соединения
        }

        //         Для чего нужен этот цикл?
        // Обработка входящих соединений:
        
        // Сервер должен быть всегда готов принимать новых клиентов.
        // Цикл обеспечивает бесконечный процесс ожидания входящих соединений.
        // Создание потока для каждого клиента:
        
        // Как только клиент подключается, сервер создаёт отдельный поток для обработки его запросов.
        // Это позволяет обрабатывать нескольких клиентов одновременно.
        // Продолжение работы после ошибок:
        
        // Если возникает ошибка при принятии соединения (например, клиент внезапно отключился), цикл пропускает ошибку и 
        // продолжает слушать другие входящие соединения.










        

        // Создание нового потока для обслуживания клиента
        thread client_thread(handle_client, client_socket);
        // 1) Зачем поток?
        // + Сервер должен обрабатывать несколько клиентов одновременно.
        // + Для каждого нового клиента создаётся отдельный поток, который выполняет функцию handle_client.
        // 2) handle_client:
        // Это функция, которая выполняет обработку взаимодействия с конкретным клиентом.
        // 3) Аргумент client_socket:
        // Передаётся в функцию handle_client для взаимодействия с клиентом через его сокет.

        
        client_thread.detach();  // Позволяет потоку работать независимо
        //         detach:
        // 1) Поток отсоединяется от основного потока и становится самостоятельным.
        // 2) После вызова detach основной поток (сервер) не может ждать завершения работы этого потока.
        // 3) Поток работает независимо, даже если основной поток завершит свою работу.

        // Почему detach, а не join?
        // 1) Если использовать join, основной поток будет ждать завершения потока клиента, что остановит сервер.
        // 2) detach позволяет серверу продолжать принимать новые соединения, не ожидая завершения работы потоков.
    }

    // Закрытие сокета сервера
    close(server_socket);
    return 0;
}
