#include <iostream>
#include <unistd.h>  // Для работы с системными вызовами, например, close()
#include <sys/socket.h>  // Для работы с сокетами  — название программного интерфейса для обеспечения обмена данными между процессами. 
#include <netinet/in.h> // Для структуры sockaddr_in и типов адресов
#include <arpa/inet.h> // Для преобразования адресов (например, inet_pton)
#include <cstring> // Для работы с C-строками, таких как memset()
#include <thread> // Для работы с потоками

using namespace std;

void receive_messages(int client_socket); // Функция для приема сообщений от сервера

int main()
{
    // создание сокета
    int client_socket = socket(AF_INET, SOCK_STREAM, 0);
    // Для создания сокета на C++ используется функция socket(). 23 Она привязывает созданный сокет к заданной параметрами транспортной инфраструктуре сети. 
    // Прототип функции: SOCKET socket(int <семейство используемых адресов>, int <тип сокета>, int <тип протокола>). 
    // Параметры:
    // Семейство адресов. Сокеты могут работать с большим семейством адресов, наиболее частое — IPv4 (указывается как AF_INET). 
    // Тип сокета. Обычно задаётся тип транспортного протокола TCP (SOCK_STREAM) или UDP (SOCK_DGRAM).  
    // Тип протокола. Необязательный параметр, если тип сокета указан как TCP или UDP — можно передать значение 0. 

    
    if (client_socket == -1)
    {
        cerr << "ERROR: cannot create socket" << endl;
        return 1;
    }
    // Результатом работы функции является целое число, которое носит название дескриптор сокета. Это значение должно быть положительным. 
    // Если функция возвращает -1, то создать сокет не удалось.


    
    // установка адреса и порта сервера
    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(12345);                    // порт 12345
    // struct sockaddr_in serverAddr — это структура, которая содержит адрес сервера и номер порта, на который нужно установить связь. 
    // Некоторые поля структуры:
    // serverAddr.sin_addr.s_addr — адрес сервера (по умолчанию INADDR_ANY); 12
    // serverAddr.sin_family — семейство адреса (AF_INET); 13
    // serverAddr.sin_port — номер порта (например, 8989). 
    // Например, для установки IP-адреса localhost можно использовать следующее назначение полей: serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1"). 
    inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr); // адрес сервера (localhost)
    // Функция inet_pton преобразует IP-адрес, представленный в виде строки, в двоичный формат, который используется в сетевых структурах, таких как sockaddr_in.
    // Чтобы передать в функцию inet_pton место, куда записать результат, нужно передать адрес переменной, в данном случае &serverAddr.sin_addr.
    // // Неправильный вариант:
    // inet_pton(AF_INET, "127.0.0.1", serverAddr.sin_addr);
    // Здесь передаётся значение, а не адрес. Компилятор выдаст ошибку.


    

    // установка соединения с сервером
    //Connect в C++ — это системный вызов, который используется для обращения программы-клиента к серверу с запросом на установление логической соединения. 
    //Параметры вызова: 
    
    // 1) s — дескриптор сокета, через который программа обращается к серверу. Socket должен быть предварительно создан и обеспечен адресом 
    // с помощью системного вызова bind. 
    // 2) addr — структура данных, содержащая адрес, приписанный сокету программы-сервера, к которой делается запрос на соединение. 
    // Для сетей TCP/IP такой структурой является sockaddr_in. 
    // addrlen — размер (в байтах) структуры данных, указываемой аргументом addr. 
    // Чтобы запрос на соединение был успешным, необходимо, чтобы программа-сервер выполнила к этому моменту системный вызов listen для сокета с указанным адресом. 
    // При успешном выполнении запроса системный вызов connect возвращает 0, в противном случае — «-1» (устанавливая код причины неуспеха 
    // в глобальной переменной errno). 
    if (connect(client_socket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1)
    {
        cerr << "ERROR: cannot connect to server" << endl;
        close(client_socket);
        return 1;
    }
    // Функция connect ожидает аргумент типа struct sockaddr*.
    // Однако мы используем структуру sockaddr_in, которая предназначена для более удобной работы с IPv4-адресами.
    // Так как sockaddr_in является частным случаем sockaddr, мы приводим её тип явно с помощью (struct sockaddr*).



    

    cout << "Connected to server." << endl;



    
    // Считываем имя пользователя
    string name;
    cout << "Please enter your name: ";
    getline(cin, name); // Читаем имя пользователя из консоли
    send(client_socket, name.c_str(), name.length(), 0); // Отправляем имя серверу
    // отправляет содержимое строки name через сокет client_socket на сервер.
    // c_str() в C++ — это функция для преобразования строки в указатель на символы. 
    // Она переводит содержимое строки в формат С-строки, то есть преобразует его в символьный массив с последним символом \0.
    cout << "Now your name is " << name << ". Enter message (type 'exit' to quit): " << endl;




    
    // Запускаем поток для приема сообщений от сервера
    thread receiver_thread(receive_messages, client_socket);
    // создаёт новый поток, который выполняет функцию receive_messages с аргументом client_socket. 
    // Потоки позволяют выполнять несколько задач одновременно, что в данном случае полезно для параллельного приёма и отправки сообщений.
    // Разбор по шагам:
    // 1. Что делает std::thread?
    // Класс std::thread в C++ используется для создания и управления потоками выполнения.
    // В данном случае создаётся новый поток, который вызывает функцию receive_messages с параметром client_socket.
    // 2. Почему нужен поток?
    // В сетевых приложениях часто требуется выполнять несколько задач одновременно. Например:
    // Один поток отвечает за приём сообщений от сервера.
    // Другой поток занимается вводом сообщений пользователя и их отправкой.
    // Если оба действия выполняются в одном потоке, программа будет "зависать" в момент ожидания входящих сообщений, так как функции, такие как recv, 
    // блокируют выполнение до получения данных.


    
    // бесконечный цикл для ввода сообщений
    string message;
    while (true)
    {
        getline(cin, message); // Читаем сообщение пользователя

        // если пользователь вводит "exit", завершаем соединение
        if (message == "exit")
        {
            break;
        }
        
        // отправка сообщения серверу
        send(client_socket, message.c_str(), message.length(), 0);
    }
    // Отсоединяем поток для приема сообщений
    receiver_thread.detach(); // Завершение работы потока (не ожидаем его завершения)
    // используется для отсоединения потока receiver_thread от основного потока программы. 
    // Это означает, что поток будет продолжать работать самостоятельно, независимо от основного потока.
    //     Что делает detach?
    // 1) Отсоединение потока:
    // После вызова detach, поток становится "неуправляемым" (detached).
    // Он продолжает своё выполнение в фоновом режиме, и основной поток больше не может его контролировать (например, ждать завершения).
    // 2) Программа завершится, не дожидаясь завершения отсоединённого потока:
    // Если основной поток завершится, а detach был вызван, то любой работающий отсоединённый поток автоматически завершится.
    // Это важно учитывать: завершение отсоединённого потока не будет синхронизировано с завершением программы.

    //         Когда используется detach?
    // 1) Фоновые задачи:
    // Поток выполняет работу, результат которой не влияет на работу основного потока (например, логирование, обработка входящих данных).
    // 2) Долгоживущие потоки:
    // Если поток работает дольше, чем основной поток, и нет необходимости ждать его завершения.
    // 3) Сетевые приложения:
    // В случае клиент-серверных приложений поток для приёма данных (receiver_thread) работает постоянно, пока активно соединение. 
    // Использование detach позволяет основному потоку завершиться после выполнения своих задач, не дожидаясь этого потока.


    //         С detach:
    // Основной поток завершится через 3 секунды, не дожидаясь завершения фонового потока.
    // Фоновый поток завершится самостоятельно через 5 секунд, но процесс может быть прерван, если основной поток завершится раньше.
    //         С join:
    // Основной поток будет ожидать завершения фонового потока, и программа завершится только после завершения обоих потоков.



    // закрытие соединения
    close(client_socket);
    return 0;
}

void receive_messages(int client_socket)
{
    char buffer[1024]; // Буфер для хранения входящих сообщений
    while (true)
    {
        memset(buffer, 0, sizeof(buffer)); // Обнуляем буфер перед использованием
        // используется для обнуления содержимого буфера buffer. Она заполняет память, начинающуюся с адреса buffer, нулями на протяжении sizeof(buffer) байт.
        // ПЕРВЫЙ АРГУМЕНТ:
        // Указатель на область памяти, которую нужно заполнить.
        // В данном случае это buffer.
        
        // ВТОРОЙ АРГУМЕНТ:
        // Значение байта, которым будет заполнена память.
        // Здесь это 0 (заполняем нулями).

        // ТРЕТИЙ АГРУМЕНТ:
        // Количество байт, которые нужно заполнить.
        // Здесь это sizeof(buffer).
        
        // + Очистка буфера:
        // Перед вызовом функции recv для приёма данных через сокет важно очистить буфер, чтобы в нём не осталось "мусора" от предыдущих операций.
        // + Безопасность данных:
        // Если буфер содержит старые данные, это может привести к неверной интерпретации или выводу лишней информации.
        // + Инициализация памяти:
        // recv не заполняет буфер полностью, если принятые данные меньше его размера. Оставшаяся часть буфера будет содержать старые значения, если они не очищены.
        
        int bytesReceived = recv(client_socket, buffer, sizeof(buffer), 0); // Получаем данные от сервера
        // Функция recv. Функция служит для чтения данных из сокета. Прототип: int recv (int s, char * buf, int len, int flags);
        // Первый аргумент - сокет-дескриптор, из которого читаются данные. 
        // Второй и третий аргументы - соответственно, адрес и длина буфера для записи читаемых данных. 
        // Четвертый параметр - это комбинация битовых флагов, управляющих режимами чтения. 
        // Если аргумент flags равен нулю, то считанные данные удаляются из сокета.

        
        //         Возвращаемое значение:
        // > 0: количество успешно принятых байт.
        // 0: удалённый конец соединения (сервер закрыл соединение).
        // -1: ошибка (например, сбой сети, неправильный дескриптор сокета). В этом случае можно использовать errno для диагностики.
        if (bytesReceived <= 0) // Проверяем, если соединение разорвано
        {
            cerr << "Disconnected from server." << endl;
            close(client_socket);
            exit(0);
        }
        buffer[bytesReceived] = '\0'; // Добавляем завершающий символ для строки
        // используется для добавления завершающего символа конца строки (\0) в конец данных, принятых через сокет. 
        // Это необходимо для преобразования данных в корректную строку в стиле C, которая заканчивается символом конца строки.
        cout << buffer << endl; // Выводим сообщение на экран
    }
}
